### 栈的表示

#### 栈的抽象数据类型

```c
ADT Stack {
  // 数据对象：
  	D = { ai | ai ∈ ElemSet, i = 1, 2, 3, ..., n, n >= 0 }
  // 数据关系：
  	R1 = { <ai-1, ai> | ai - 1, ai ∈ D, i = 1, 2, 3, ..., n  }
  // 基本操作：初始化、进栈、出栈、取元素等
} ADT Stack
```

#### 栈的存储

> 顺序结构存储被称为顺序栈

利用数组存储，栈顶入栈与出栈。附设top（一般指向栈顶元素之上的这个元素下标，方便操作）、base指针分别指向栈顶和栈底位置，另外用stacksize（主要为了防止越界，js直接取length即可）表示栈可使用的最大容量。

- 空栈标志：`top == base`
- 栈满标志：`top - base = stacksize`
- 上溢（overflow）：栈已满，又要压入元素；是一种让程序无法执行的错误
- 下溢（underflow）：栈已经空了，还要弹出元素；是结束条件而不是错误

> 链式结构存储被称为链栈

链栈是运算受限的单链表，只能在链表头部进行操作。

- 链表的头指针指向栈顶an，在单链表中被称为尾指针
- 不需要头结点
- 基本不存在栈满的情况，除非内存没有可分配的空间
- 空栈相当于头指针指向空（null）
- 插入和删除仅在栈顶处执行

### 链栈的操作

#### 链栈的表示

```c
typedef struct StackNode{
  SElemType data;
  struct StackNode *next;
}StackNode, *LinkStack;
LinkStack S;
```

#### 初始化

```c
void InitStack(LinkStack &S) {
  S = NULL;
  return OK;
}
```

#### 是否为空

```c
Status StackEmpty(LinkStack S) {
  if(S == NULL) return TRUE
  return FALSE
}
```

#### 入栈

```c
Status Push(LinkStack &S, SElemType e) {
  p = new StackNode // 生成新结点
  p -> data = e  // 将结点数据域赋值
  p -> next = S // 把p插入栈顶
  S = p // 修改栈顶指针
  return OK
}
```

#### 出栈

```c
Status Pop(LinkStack &S, SElemType &e) {
  if(S == NULL) return ERROR
  e = S -> data
  p = S // 暂存此时要删除的结点
  S = S -> next // 栈顶指针下移
  delete p // 删除结点
  return e
}
```

#### 取栈顶操作

```c
SElemType GetTop(LinkStack S){
  if(S != NULL) return S -> data
}
```

### 顺序栈的操作

#### 顺序栈的表示

```c
#define MAXSIZE 100
typedef struct StackNode{
  SElemType *base;
  SElemType *top;
  int stacksize;
}SqStack
```

#### 初始化

```c
// 构造一个空栈 S
Status InitStack(SqStack &S){
  S.base = new SElemType[MAXSIZE]
  if(!S.base) exit (OVERFLOW)
  S.top = S.base
  S.stacksize = MAXSIZE
  return OK;
}
```

#### 栈是否为空

```c
Status StackEmpty(SqStack S){
  if(S.top == S.base) return TURE
  return FALSE
}
```

#### 销毁栈

```c
// S 存在，则销毁
Status DestoryStack(SqStack &S){
	if(S.base) {
    delete S.base
    S.stacksize = 0
    S.base = S.top = NULL
  }
  return OK
}
```

#### 求栈的长度

```c
int StackLength(SqStack S) {
  return S.top - S.base
}
```

#### 清空栈

```c
Status ClearStack(SqStack S) {
  // 不用一个个删除
  if(S.base) S.top = S.base
  return OK
}
```

#### 入栈

```c
Status Push(SqStack &S, SElemType e){
	if(S.top - S.base == S.stacksize) return ERROR
  *S.top++=e // 1. *S.top = e   2.  S.top ++
  return OK
}
```

#### 出栈

```c
Status Pop(SqStack &S, SElemType &e){
  if(S.top == S.base) return ERROR
  e = *--S.top // 1. --S.top   2. e = *S.top
  return e
}
```

