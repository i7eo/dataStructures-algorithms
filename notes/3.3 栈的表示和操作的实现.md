### 栈的表示

#### 栈的抽象数据类型

```c
ADT Stack {
  // 数据对象：
  	D = { ai | ai ∈ ElemSet, i = 1, 2, 3, ..., n, n >= 0 }
  // 数据关系：
  	R1 = { <ai-1, ai> | ai - 1, ai ∈ D, i = 1, 2, 3, ..., n  }
  // 基本操作：初始化、进栈、出栈、取元素等
} ADT Stack
```

#### 栈的存储

> 顺序结构存储被称为顺序栈

利用数组存储，栈顶入栈与出栈。附设top（一般指向栈顶元素之上的这个元素下标，方便操作）、base指针分别指向栈顶和栈底位置，另外用stacksize（主要为了防止越界，js直接取length即可）表示栈可使用的最大容量。

- 空栈标志：`top == base`
- 栈满标志：`top - base = stacksize`
- 上溢（overflow）：栈已满，又要压入元素；是一种让程序无法执行的错误
- 下溢（underflow）：栈已经空了，还要弹出元素；是结束条件而不是错误

> 链式结构存储被称为链栈

### 顺序栈的操作

#### 顺序栈的表示

```c
#define MAXSIZE 100
typedef struct{
  SElemType *base;
  SElemType *top;
  int stacksize;
}SqStack
```

#### 初始化

```c
// 构造一个空栈 S
Status InitStack(SqStack &S){
  S.base = new SElemType[MAXSIZE]
  if(!S.base) exit (OVERFLOW)
  S.top = S.base
  S.stacksize = MAXSIZE
  return OK;
}
```

#### 栈是否为空

```c
Status StackEmpty(SqStack S){
  if(S.top == S.base) return TURE
  return FALSE
}
```

#### 销毁栈

```c
// S 存在，则销毁
Status DestoryStack(SqStack &S){
	if(S.base) {
    delete S.base
    S.stacksize = 0
    S.base = S.top = NULL
  }
  return OK
}
```

#### 求栈的长度

```c
int StackLength(SqStack S) {
  return S.top - S.base
}
```

#### 获取栈顶元素

```c
GetTop()
```

#### 清空栈

```c
Status ClearStack(SqStack S) {
  // 不用一个个删除
  if(S.base) S.top = S.base
  return OK
}
```

#### 入栈

```c
Status Push(SqStack &S, SElemType e){
	if(S.top - S.base == S.stacksize) return ERROR
  *S.top++=e // 1. *S.top = e   2.  S.top ++
  return OK
}
```

#### 出栈

```c
Status Pop(SqStack &S, SElemType &e){
  if(S.top == S.base) return ERROR
  e = *--S.top // 1. --S.top   2. e = *S.top
  return e
}
```

