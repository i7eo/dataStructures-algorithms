### 定义

树（Tree）是 n（n>= 0）个结点的有限集。

- 若 n=0，则称为空树
- 若 n>0，则
  - 有且仅有一个特定的称为根（root）的结点
  - 其余结点可分为m（m>=0）个互不相交的有限集 T1, T2, ..., Tm

森林是 m（m>=0）棵互不相交的树的集合。一个树去掉根结点就成为了森林，森林中的每一个树都有一个相同的根结点那么森林就成为了树。

### 树的表示

#### 双亲表示法

实现：定义结构数组，存放树的结点，每个结点含俩个域：

- 数据域：存放结点本身的信息
- 双亲域：指示本结点的双亲结点在数组中的位置

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/树的双亲表示法.jpeg" style="zoom:50%;" />

特点：找双亲很容易，找孩子则较难需要遍历匹配

```c
// 孩子结点
typedef struct PTNode {
  TElemType data;
  int parent; // 双亲位置域
}PTNode

// 树结构
#define MAX_TREE_SIZE 100
typedef struct {
  PTNode nodes[MAX_TREE_SIZE];
  int r,n; // 根结点的位置和结点总数
}PTree
```

#### 孩子链表

实现：把每个结点的孩子结点排列起来，看成一个线性表，用单链表存储，则n个结点有n个孩子链表（叶子的孩子链表为空表）。而n个头指针又组成一个线性表，用顺序表（含n个元素的结构数组存储）。

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/孩子链表表示法.jpeg" style="zoom:50%;" />

特点：找孩子很容易，找双亲则较难需要遍历匹配

```c
// 孩子结点
typedef struct CTNode {
  int child;
  struct CTNode *next; // 指向下一个孩子结点
}*ChildPtr
  
// 双亲结点
typedef struct {
  TElemType data;
  ChildPtr firstchild; // 孩子链表头指针
}CTBox
  
// 树结构
typedef struct {
  CTBox nodes[MAX_TREE_SIZE];
  int n,r; // 结点数和根结点的位置
}CTree
```

#### 带双亲的孩子链表

由上面俩个方法可知，都有缺点。

但是在孩子链表中的存储双亲结点的位置上增加一项来存储双亲的位置，那么即可完美兼容。这种做法被称作**带双亲的孩子链表**

#### 二叉链表表示法（二叉树表示法，孩子兄弟表示法）

实现：用二叉链表作为树的存储结构，链表中的每个结点的俩个指针域分别指向其第一个孩子结点和**下一个兄弟结点**。

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/二叉链表表示法.jpeg" style="zoom:50%;" />

```c
typedef struct CSNode {
  ElemType data;
  struct CSNode *firstchild, *nextsibling;
}CSNode, *CSTree
```

### 树的运算

因为树的运算较复杂，一般情况下我们要先将树转为二叉树进行处理，利用二叉树的算法来实现对树的操作。

由于树和二叉树都可以用二叉链表作为存储结构，则**以二叉链表作媒介**可以导出树与二叉树之间的对应关系来做转换。

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/树转换为二叉树.JPG" style="zoom:50%;" />

> 树转换为二叉树的转换规则：
>
> - 加线：在兄弟之间加一条线
> - 抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系
> - 调整：以树的根结点为轴心，将整数顺时针转45度
>
> 总结：兄弟相连留长子

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/树转换为二叉树过程.JPG" style="zoom:20%;" />

> 二叉树转换为树的转换规则：
>
> - 加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子。。。沿分支找到的所有右孩子，都与p的双亲用线连起来
> - 抹线：抹掉原二叉树中双亲与右孩子之间的连线
> - 调整：将结点按层次排列，形成树结构
>
> 总结：左孩右右连双亲，去掉原来右孩线

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/二叉树转树.JPG" style="zoom:50%;" />

将树转换成二叉树后即可使用二叉树的各种预算来进行操作。

### 森林的运算

因为森林的运算较复杂，一般情况下我们要先将森林转为二叉树集合再进行处理，利用二叉树的算法来实现对树的操作。

> 森林转换成二叉树
>
> - 将各课树分别转换成二叉树
> - 将每棵树的根结点用线相连
> - 以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树形结构
>
> 总结：树变二叉根相连

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/森林转二叉树.JPG" style="zoom:50%;" />

> 二叉树转换成森林
>
> - 将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉，使之变成孤立的二叉树
> - 将孤立的二叉树还原成树
>
> 总结：去掉全部右孩线，孤立二叉再还原

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/二叉树转森林.JPG" style="zoom:50%;" />
