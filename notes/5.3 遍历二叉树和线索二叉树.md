## 遍历二叉树

### 遍历的定义

顺着某一条搜索路径依次访问二叉树中的结点，使得每个结点均被访问一次，而且**仅被访问一次**。

> “访问”的含义很广，一般是指对结点作访问。这里只要是指对结点作的各种处理，如：输出结点的信息，修改结点的值等。这种访问不能破坏原来的数据结构

### 遍历的目的

得到树中的所有结点的线性排列。但是从根结点开始遍历，应该先访问左孩子还是右孩子呢？这种不明确的情况就是1对多且非线性的情况，如果要得到线性排列那就得先确定遍历的顺序

### 遍历的用途

遍历是树结构crud和排序运算的前提，**是二叉树一切运算的基础和核心**。

### 遍历二叉树算法描述

假设：遍历左子树（L）、访问根结点（D）、遍历右子树（R），则遍历整个二叉树的方案共有：LDR、LRD、DLR、DRL、RLD、RDL 六种。

若规定顺序为先左后右，则只有三种情况如下：

- DLR 先（根）序遍历
- LDR 中（根）序遍历
- LRD 后（根）序遍历

 详细描述如下：

- 先序遍历二叉树：若二叉树为空，则空操作。否则：
  1. 访问根结点
  2. 先序遍历左子树
  3. 先序遍历右子树
  4. 递归以上操作直至结束
- 中序遍历二叉树：若二叉树为空，则空操作。否则：
  1. 先序遍历左子树
  2. 访问根结点
  3. 先序遍历右子树
  4. 递归以上操作直至结束
- 后序遍历二叉树：若二叉树为空，则空操作。否则：
  1. 先序遍历左子树
  2. 先序遍历右子树
  3. 访问根结点
  4. 递归以上操作直至结束

例子：

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/二叉树遍历.JPG" style="zoom:20%;" />

#### 结论

- 若二叉树中各结点的值均不相同，则二叉树结点的先序序列、中序序列和后续序列的是唯一的
- 由二叉树的先序序列和中序序列或由二叉树的后续序列和中序序列可以确定唯一一颗二叉树

例子：

已知二叉树的先序和中序序列，构造出相应的二叉树：

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/生成二叉树.JPG" style="zoom:25%;" />

需要注意的是先序是中左右，所以根据先序就可以确定父(根)结点；后序是左中右，根据后序则可以确定左右子树

**每个子结点都必须生于父结点，而前序和后序都可以确定父结点。所以前序、后序任意和中序组合都可确定二叉树。**

## 遍历算法的实现

### 先序遍历

实现：若二叉树为空，则空操作；若二叉树非空，访问根结点D，前序遍历左子树L，前序遍历右子树R

存储：双向链表

```c
Status PreOrderTraverse(BiTree T) {
  if(T == NULL) {
    return OK; 
  }else{
    visit(T) // 通过 T -> data 拿到节点值进行操作
    PreOrderTraverse(T -> lchild)
    PreOrderTraverse(T -> rchild)
  }
}
```

 ### 中序遍历

```c
Status InOrderTraverse(BiTree T) {
  if(T == NULL) {
    return OK; 
  }else{
    PreOrderTraverse(T -> lchild)
    visit(T) // 通过 T -> data 拿到节点值进行操作
    PreOrderTraverse(T -> rchild)
  }
}
```

 ### 后序遍历

```c
Status PostOrderTraverse(BiTree T) {
  if(T == NULL) {
    return OK; 
  }else{
    PreOrderTraverse(T -> lchild)
    PreOrderTraverse(T -> rchild)
    visit(T) // 通过 T -> data 拿到节点值进行操作
  }
}
```

### 总结

- 如果去掉输出语句，从递归的角度看完全相同的，只是访问结点的时机不同
- 第一次经过时访问为先序遍历，第二次经过时访问为中序遍历，第三次经过时访问为后序遍历
- 时间复杂度：O(n)，**递归调用的时候需要把调用函数的地址和变量保存下来方便下一层的调用，要存在栈中** 空间复杂度: O(n)

### 中序遍历的非递归算法

利用栈先进后出的特性来实现

```c
Status InOrderTraverse(BiTree T) {
  BiTree p; InitStack(S); p = T;
  while(p || !StackEmpty(S)) {
    if(p) {
      Push(S, p);
      p = p -> lchild
    }else{
      Pop(S, q) // q 为弹出的元素
      printf(q -> data)
      p = q -> rchild
    }
  }
  return OK
}
```

### 二叉树的层次遍历

对于一颗二叉树，从根结点开始，按**从上到下、从左到右的顺序**访问每一个结点。利用队列先进先出的特性来实现

```c
// 定义循环队列
typedef struct {
  BTNode data[MaxSize];
  int front, rear;
}SqQueue
  
void LevelOrder(BTNode *b) {
  BTNode *p;
  SqQueue *qu;
  InitQueue(qu)
  enQueue(qu, b) // 根结点入队
  while(!QueueEmpty(qu)) { // 队列不为空则循环
    deQueue(qu, p) // 出队头结点
    printf(p -> data)
    if(p -> lchild != NULL) enQueue(qu, p -> lchild)
    if(p -> rchild != NULL) enQueue(qu, p -> rchild)
  }
}
```

## 二叉树遍历算法的应用

### 二叉树的建立

已知先序序列为：ABCDEGF，建立二叉树的二叉链表

- 从键盘输入二叉树的结点，建立二叉树的存储结构。注意因为单纯输入先序结点会生成不止一棵树，所以以其中一种树为目标，用空结点补齐
- 建立二叉树的过程中按照二叉树先序的方式建立

生成的树如下：ABC##DE#G##F### （#表示空结点）

```c
Status CreateBiTree(BiTree &T) {
  scanf(&ch) // 获取键盘输入值
  if(ch == '#') {
  	T = NULL
  }else{
  	if(!(T = (BiNode*) malloc(sizeof(BiTNode)))) exit(OVERFLOW) // 申请内存分配给T，分配不成功退出
    T -> data = ch;
    CreateBiTree(T -> lchild);
    CreateBiTree(T -> rchild);
  }
  return OK
}
```

### 复制二叉树

思路：如果是空树，递归结束；否则，申请新结点空间，复制根结点，递归复制左子树，递归复制右子树

```c
int Copy(BiTree T, BiTree &NewT) {
  if(T == NULL) {
    NewT = NULL;
    return 0;
  }else{
    NewT = new BiTNode;
    NewT -> data = T -> data;
    Copy(T -> lchild, NewT -> lchild);
    Copy(T -> rchild, NewT -> rchild); 
  }
}
```

### 计算二叉树深度

思路：如果是空树，则深度为0；否则，递归计算左子树的深度记为m，递归计算右子树的深度记为n，二叉树的深度则为m与n的较大值并且加1

```c
int Depth(BiTree T) {
  if(T == NULL) {
    return 0;
  }else{
    m = Depth(T -> lchild); // 需要注意的是这俩句不执行完（即有返回）始终都不会进入到下方进行深度计算
    n = Depth(T -> rchild); // 需要注意的是这俩句不执行完（即有返回）始终都不会进入到下方进行深度计算，要结合程序语言函数调用的栈逻辑去理解
    if(m > n) {
      return m + 1;
    }else{
      return n + 1;
    }
  }
}
```

### 计算二叉树结点总数

思路：如果是空树，则结点个数为0；否则，结点个数为左子树的结点个数 + 右子树的结点个数 + 1

```c
int NodeCount(BiTree T) {
  if(T == NULL) {
    return 0;
  }else{
    return NodeCount(T -> lchild) + NodeCount(T -> rchild) + 1
  }
}
```

### 计算二叉树叶子结点个数

思路：如果是空树，则叶子结点个数为0；否则，为左子树的叶子结点个数 + 右子树的叶子结点个数

```c
int LeafCount(BiTree T) {
  if(T == NULL) {
    return 0
  }else if(T -> lchild == NULL && T -> rchild == NULL) {
    return 1
  }else{
    return LeafCount(T -> lchild) + LeafCount(T -> rchild)
  }
}
```

## 线索二叉树

> 为什么要研究线索二叉树？
>
> 当用二叉链表作为二叉树的存储结构时，可以很方便地找到某个结点的左右孩子；但一般情况下，**无法直接找到该结点在某种遍历序列中的前驱和后继结点**

那么如何寻找特定遍历序列中二叉树结点的前驱和后继？

解决办法：

- 通过遍历寻找（用时间换空间）
- 通过给结点多增加俩个空间的方式存储前驱、后继结点（用空间换时间）
- 利用二叉链表中空的指针域存储

实现思路：

如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱；如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继。

**这种改变指向的指针称为“线索”**，加上了线索的二叉树称为线索二叉树(Theaded Binary Tree)

对二叉树按某种遍历次序使其变为线索二叉树的过程叫**线索化**

为了区分 lchild 和 rchild 指针到底是指向孩子的指针还是指向前驱或者后继的指针，对二叉链表中每个结点增设俩个标志域 ltag 和 rtag，并约定：

- ltag = 0  lchild 指向该结点的左孩子
- ltag = 1  lchild 指向该结点的前驱
- rtag = 0  rchild 指向该结点的右孩子
- rtag = 1  rchild 指向该结点的后继

```c
typedef struct BiThrNode {
  int data;
  int ltag, rtag; // 存放0、1
  struct BiThrNode *lchild, rchild;
}BiThrNode, *BiThrNode
```

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/先序线索二叉树.JPG" style="zoom:60%;" />

  从上面的例子不难看出结点 e 的 rchild 为空，为了避免出现这种悬空状态。解决方案：

- 二叉链表增设一个头结点
- 头结点 ltag = 0，lchild 指向根结点
- 头结点 rtag = 1，rchild 指向遍历序列中最后一个结点
- 悬空状态的指针域全部指向头结点
