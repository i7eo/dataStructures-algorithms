## 遍历二叉树

### 遍历的定义

顺着某一条搜索路径依次访问二叉树中的结点，使得每个结点均被访问一次，而且**仅被访问一次**。

> “访问”的含义很广，一般是指对结点作访问。这里只要是指对结点作的各种处理，如：输出结点的信息，修改结点的值等。这种访问不能破坏原来的数据结构

### 遍历的目的

得到树中的所有结点的线性排列。但是从根结点开始遍历，应该先访问左孩子还是右孩子呢？这种不明确的情况就是1对多且非线性的情况，如果要得到线性排列那就得先确定遍历的顺序

### 遍历的用途

遍历是树结构crud和排序运算的前提，**是二叉树一切运算的基础和核心**。

### 遍历二叉树算法描述

假设：遍历左子树（L）、访问根结点（D）、遍历右子树（R），则遍历整个二叉树的方案共有：LDR、LRD、DLR、DRL、RLD、RDL 六种。

若规定顺序为先左后右，则只有三种情况如下：

- DLR 先（根）序遍历
- LDR 中（根）序遍历
- LRD 后（根）序遍历

 详细描述如下：

- 先序遍历二叉树：若二叉树为空，则空操作。否则：
  1. 访问根结点
  2. 先序遍历左子树
  3. 先序遍历右子树
  4. 递归以上操作直至结束
- 中序遍历二叉树：若二叉树为空，则空操作。否则：
  1. 先序遍历左子树
  2. 访问根结点
  3. 先序遍历右子树
  4. 递归以上操作直至结束
- 后序遍历二叉树：若二叉树为空，则空操作。否则：
  1. 先序遍历左子树
  2. 先序遍历右子树
  3. 访问根结点
  4. 递归以上操作直至结束

例子：

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/二叉树遍历.JPG" style="zoom:20%;" />

#### 结论

- 若二叉树中各结点的值均不相同，则二叉树结点的先序序列、中序序列和后续序列的是唯一的
- 由二叉树的先序序列和中序序列或由二叉树的后续序列和中序序列可以确定唯一一颗二叉树

例子：

已知二叉树的先序和中序序列，构造出相应的二叉树：

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/生成二叉树.JPG" style="zoom:25%;" />

需要注意的是先序是中左右，所以根据先序就可以确定父(根)结点；后序是左中右，根据后序则可以确定左右子树

**每个子结点都必须生于父结点，而前序和后序都可以确定父结点。所以前序、后序任意和中序组合都可确定二叉树。**

## 遍历算法的实现

### 先序遍历

实现：若二叉树为空，则空操作；若二叉树非空，访问根结点D，前序遍历左子树L，前序遍历右子树R

存储：双向链表

```c
Status PreOrderTraverse(BiTree T) {
  if(T == NULL) {
    return OK; 
  }else{
    visit(T) // 通过 T -> data 拿到节点值进行操作
    PreOrderTraverse(T -> lchild)
    PreOrderTraverse(T -> rchild)
  }
}
```

 ### 中序遍历

```c
Status InOrderTraverse(BiTree T) {
  if(T == NULL) {
    return OK; 
  }else{
    PreOrderTraverse(T -> lchild)
    visit(T) // 通过 T -> data 拿到节点值进行操作
    PreOrderTraverse(T -> rchild)
  }
}
```

 ### 后序遍历

```c
Status PostOrderTraverse(BiTree T) {
  if(T == NULL) {
    return OK; 
  }else{
    PreOrderTraverse(T -> lchild)
    PreOrderTraverse(T -> rchild)
    visit(T) // 通过 T -> data 拿到节点值进行操作
  }
}
```

### 总结

- 如果去掉输出语句，从递归的角度看完全相同的，只是访问结点的时机不同
- 第一次经过时访问为先序遍历，第二次经过时访问为中序遍历，第三次经过时访问为后序遍历
- 时间复杂度：O(n)，**递归调用的时候需要把调用函数的地址和变量保存下来方便下一层的调用，要存在栈中** 空间复杂度: O(n)

### 中序遍历的非递归算法

利用栈先进后出的特性来实现

```c
Status InOrderTraverse(BiTree T) {
  BiTree p; InitStack(S); p = T;
  while(p || !StackEmpty(S)) {
    if(p) {
      Push(S, p);
      p = p -> lchild
    }else{
      Pop(S, q) // q 为弹出的元素
      printf(q -> data)
      p = q -> rchild
    }
  }
  return OK
}
```

### 二叉树的层次遍历

对于一颗二叉树，从根结点开始，按**从上到下、从左到右的顺序**访问每一个结点。利用队列先进先出的特性来实现

```c
// 定义循环队列
typedef struct {
  BTNode data[MaxSize];
  int front, rear;
}SqQueue
  
void LevelOrder(BTNode *b) {
  BTNode *p;
  SqQueue *qu;
  InitQueue(qu)
  enQueue(qu, b) // 根结点入队
  while(!QueueEmpty(qu)) { // 队列不为空则循环
    deQueue(qu, p) // 出队头结点
    printf(p -> data)
    if(p -> lchild != NULL) enQueue(qu, p -> lchild)
    if(p -> rchild != NULL) enQueue(qu, p -> rchild)
  }
}
```

