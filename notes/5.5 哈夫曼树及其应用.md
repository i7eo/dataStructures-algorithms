## 哈夫曼树的引出

> 示例：将学生百分制成绩转换为五分制成绩，<60 => E/60-79 => D/70-79 => C/80-89 => B/90-100 => A

```c
if(score < 60) 
  grade = 'E'
else if(score < 70)
  grade = 'D'
else if(score < 80)
  grade = 'C'
else if(score < 90)
  grade = 'B'
else if(score < 100)
  grade = 'A'
  
// 这种用于描述分类过程的结构可以改为二叉树，称为判断树
```

判断树如下：

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/哈夫曼树由来-1.JPG" style="zoom:50%;" />

改进判断树：

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/哈夫曼树由来-2.JPG" style="zoom:50%;" />

如何更快的找到最优二叉树，这正是哈夫曼研究的问题，也被称为哈夫曼树。

## 哈夫曼树的概念

- 路径：从树中一个结点到另一个结点之间的**分支**构成这俩个结点间的路径
- 结点的路径长度：俩结点间路径上的**分支数**
- 树的路径长度：从树根到每一个结点的路径长度之和。记作：TL 
- 权(weight)：将树中结点赋给一个有着**某种含义的数值**，则这个数值称为该结点的权。（上面例子中的百分比就是权，因为结点有了权才有了衡量最优的标准）
- 结点的带权路径长度：从**根结点**到该结点之间的路径长度与该结点权的乘积
- 树的带权路径长度：树中**所有叶子结点**的带权路径长度之和。记作：WPL

示例如下：

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/哈夫曼树基本概念示例.JPG" style="zoom:50%;" />

问题：有4个结点a, b, c, d, 权值分别为 7，5，2，4，构造以此4个结点为叶子结点的二叉树。具体如下：

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/哈夫曼树基本概念示例2.JPG" style="zoom:20%;" />

> 哈夫曼树就是带权路径长度（WPL）最短的树，即最优树。
>
> 需要注意的是，从上面的例子3可以看到当所有的叶子结点全部挂在根结点下形成n叉树后，WPL是最小的。但我们在求解哈夫曼树比较带权路径长度（WPL）最短时，树的度必须是一致的，否则比较就没有意义。因此有最优二叉树、最优三叉树之称等等。
>
> 因为构造这种树的算法是由哈夫曼教授提出的，所以这种树被称为哈夫曼树，相应的算法被称为哈夫曼算法。

哈夫曼树的特点：

- 满二叉树不一定是哈夫曼树
- 权值大的结点离根结点近，权值小的结点离根结点远
- 具有相同带权路径长度的哈夫曼树并不惟一

## 构造哈夫曼树

