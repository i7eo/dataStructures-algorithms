## 哈夫曼树的引出

> 示例：将学生百分制成绩转换为五分制成绩，<60 => E/60-79 => D/70-79 => C/80-89 => B/90-100 => A

```c
if(score < 60) 
  grade = 'E'
else if(score < 70)
  grade = 'D'
else if(score < 80)
  grade = 'C'
else if(score < 90)
  grade = 'B'
else if(score < 100)
  grade = 'A'
  
// 这种用于描述分类过程的结构可以改为二叉树，称为判断树
```

判断树如下：

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/哈夫曼树由来-1.JPG" style="zoom:50%;" />

改进判断树：

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/哈夫曼树由来-2.JPG" style="zoom:50%;" />

如何更快的找到最优二叉树，这正是哈夫曼研究的问题，也被称为哈夫曼树。

## 哈夫曼树的概念

- 路径：从树中一个结点到另一个结点之间的**分支**构成这俩个结点间的路径
- 结点的路径长度：俩结点间路径上的**分支数**
- 树的路径长度：从树根到每一个结点的路径长度之和。记作：TL 
- 权(weight)：将树中结点赋给一个有着**某种含义的数值**，则这个数值称为该结点的权。（上面例子中的百分比就是权，因为结点有了权才有了衡量最优的标准）
- 结点的带权路径长度：从**根结点**到该结点之间的路径长度与该结点权的乘积
- 树的带权路径长度：树中**所有叶子结点**的带权路径长度之和。记作：WPL

示例如下：

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/哈夫曼树基本概念示例.JPG" style="zoom:50%;" />

问题：有4个结点a, b, c, d, 权值分别为 7，5，2，4，构造以此4个结点为叶子结点的二叉树。具体如下：

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/哈夫曼树基本概念示例2.JPG" style="zoom:20%;" />

> 哈夫曼树就是带权路径长度（WPL）最短的树，即最优树。
>
> 需要注意的是，从上面的例子3可以看到当所有的叶子结点全部挂在根结点下形成n叉树后，WPL是最小的。但我们在求解哈夫曼树比较带权路径长度（WPL）最短时，树的度必须是一致的，否则比较就没有意义。因此有最优二叉树、最优三叉树之称等等。
>
> 因为构造这种树的算法是由哈夫曼教授提出的，所以这种树被称为哈夫曼树，相应的算法被称为哈夫曼算法。

哈夫曼树的特点：

- 满二叉树不一定是哈夫曼树
- **权值大的结点离根结点近，权值小的结点离根结点远**
- 具有相同带权路径长度的哈夫曼树并不惟一

## 构造哈夫曼树

基于哈夫曼树**权值大的结点离根结点近，权值小的结点离根结点远**的特点，我们可以借鉴贪心算法的思想，首先选择权值小的结点来当作叶子结点。

哈夫曼算法：

- 根据n个给定的权值（w1, w2, ..., wn）构成n棵二叉树的森林 F = { T1, T2, ..., Tn }，其中 Ti 只有一个带权为 wi 的根结点。【构造森林全是根】
- 在 F 中选取俩棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树根结点的权值为其左右子树上根结点的权值之和。【选用俩小造新树】
- 在 F 中删除这俩棵树，同时将新得到的二叉树加入森林中。【删除俩小添新人】
- 重复步骤2、3，直到森林中只有一棵树为止，这棵树即为哈夫曼树。【重复2、3剩单根】

例子：有4个结点a、b、c、d，权值分别为7，5，2，4，构造哈夫曼树

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/构造哈夫曼树.JPG" style="zoom:50%;" />

总结：

1. 哈夫曼树的结点度数为0或2，没有度为1的结点
2. 包含n个叶子结点的哈夫曼树中共有2n-1个结点（因为包含n棵树的森林要经过n-1次合并才能形成哈夫曼树，共产生n-1个新结点，再加上原本的n个结点即2n-1）
3. 其中产生的n-1个新结点度均为2，原本的n个结点度均为0

