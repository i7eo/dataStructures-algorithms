## 哈夫曼树的引出

> 示例：将学生百分制成绩转换为五分制成绩，<60 => E/60-79 => D/70-79 => C/80-89 => B/90-100 => A

```c
if(score < 60) 
  grade = 'E'
else if(score < 70)
  grade = 'D'
else if(score < 80)
  grade = 'C'
else if(score < 90)
  grade = 'B'
else if(score < 100)
  grade = 'A'
  
// 这种用于描述分类过程的结构可以改为二叉树，称为判断树
```

判断树如下：

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/哈夫曼树由来-1.JPG" style="zoom:50%;" />

改进判断树：

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/哈夫曼树由来-2.JPG" style="zoom:50%;" />

如何更快的找到最优二叉树，这正是哈夫曼研究的问题，也被称为哈夫曼树。

## 哈夫曼树的概念

- 路径：从树中一个结点到另一个结点之间的**分支**构成这俩个结点间的路径
- 结点的路径长度：俩结点间路径上的**分支数**
- 树的路径长度：从树根到每一个结点的路径长度之和。记作：TL 
- 权(weight)：将树中结点赋给一个有着**某种含义的数值**，则这个数值称为该结点的权。（上面例子中的百分比就是权，因为结点有了权才有了衡量最优的标准）
- 结点的带权路径长度：从**根结点**到该结点之间的路径长度与该结点权的乘积
- 树的带权路径长度：树中**所有叶子结点**的带权路径长度之和。记作：WPL

示例如下：

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/哈夫曼树基本概念示例.JPG" style="zoom:50%;" />

问题：有4个结点a, b, c, d, 权值分别为 7，5，2，4，构造以此4个结点为叶子结点的二叉树。具体如下：

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/哈夫曼树基本概念示例2.JPG" style="zoom:20%;" />

> 哈夫曼树就是带权路径长度（WPL）最短的树，即最优树。
>
> 需要注意的是，从上面的例子3可以看到当所有的叶子结点全部挂在根结点下形成n叉树后，WPL是最小的。但我们在求解哈夫曼树比较带权路径长度（WPL）最短时，树的度必须是一致的，否则比较就没有意义。因此有最优二叉树、最优三叉树之称等等。
>
> 因为构造这种树的算法是由哈夫曼教授提出的，所以这种树被称为哈夫曼树，相应的算法被称为哈夫曼算法。

哈夫曼树的特点：

- 满二叉树不一定是哈夫曼树
- **权值大的结点离根结点近，权值小的结点离根结点远**
- 具有相同带权路径长度的哈夫曼树并不惟一

## 构造哈夫曼树

基于哈夫曼树**权值大的结点离根结点近，权值小的结点离根结点远**的特点，我们可以借鉴贪心算法的思想，首先选择权值小的结点来当作叶子结点。

哈夫曼算法：

- 根据n个给定的权值（w1, w2, ..., wn）构成n棵二叉树的森林 F = { T1, T2, ..., Tn }，其中 Ti 只有一个带权为 wi 的根结点。【构造森林全是根】
- 在 F 中选取俩棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树根结点的权值为其左右子树上根结点的权值之和。【选用俩小造新树】
- 在 F 中删除这俩棵树，同时将新得到的二叉树加入森林中。【删除俩小添新人】
- 重复步骤2、3，直到森林中只有一棵树为止，这棵树即为哈夫曼树。【重复2、3剩单根】

例子：有4个结点a、b、c、d，权值分别为7，5，2，4，构造哈夫曼树

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/构造哈夫曼树.JPG" style="zoom:50%;" />

总结：

1. 哈夫曼树的结点度数为0或2，没有度为1的结点
2. 包含n个叶子结点的哈夫曼树中共有2n-1个结点（因为包含n棵树的森林要经过n-1次合并才能形成哈夫曼树，共产生n-1个新结点，再加上原本的n个结点即2n-1）
3. 其中产生的n-1个新结点度均为2，原本的n个结点度均为0

## 构造哈夫曼树算法实现

### 存储结构

数组、链表均可，这里使用一维数组存储。结点类型定义如下：

```c
typedef struct {
  int weight;
  int parent, lch, rch; // 这三个值存的均为数组的索引
}HTNode, *HuffmanTree
```

这里的数组长度为 2n - 1个，一般把0位置空出来从1开始。

```c
void CreateHuffmanTree(HuffmanTree HT, int n) {
  if(n < 1) return;
  m = 2 * n - 1;
  
  // 初始化（构造森林全是根）
  HT = new HTNode[m + 1] // 索引0处的元素没有使用，需要补一位
  for(i = 1; i<=m; ++i) {
    // 初始化对象数组中的属性 lch rch parent
    // parent为0代表未使用，不为0代表使用过该结点构造树
    HT[i].lch = HT[i].rch = HT[i].parent = 0
  }
  for(i = 1; i<=n; ++i) {
    // 初始化权重
    cin >> HT[i].weight
  }
  
  // 进行以下n-1次合并，依次产生n-1个结点HT[i], i = n+1, ..., 2n-1
  for(i = n + 1; i <= m; i++) {
    select(HT, i-1, s1, s2) // 在HT[k](1<=k<=i-1)中选择俩个其双亲域为0且权值最小的俩个值并返回索引s1，s2
    HT[s1].parent = HT[s2].parent = i // 设置parent标识（删除俩小）
    HT[i].lch = s1;HT[i].rch = s2; // s1，s2分别作为i的左右孩子（添新人）
    HT[i].weight = HT[s1].weight + HT[s2].weight
  }
}
```

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/哈夫曼树的存储示例.JPG" style="zoom:50%;" />

**这里求G结点的编码，需要理解哈夫曼编码后，通过 parent 不断回溯可以得到**

## 哈夫曼树的应用—哈夫曼编码 

例子：在远程通讯中，要将待传字符转换成二进制字符串。假设要传送的字符为：ABACCDA。

方法一：等长编码，A:00, B:01, C:10, D:11。利用此约定可将字符串转换为 00010010101100

**方法一问题也很明显，全部字符等长，一旦数据量变大后就会占用很大的空间**

方法二：不定长编码，即让待传字符串中出现次数较多的字符采用尽可能短的编码，则转换的二进制字符即可减少。

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/哈夫曼编码由来.JPG" style="zoom:50%;" />

如何解决任意一个字符不是另一个字符编码的前缀？（如上的A与B）

利用哈夫曼编码解决。

> 哈夫曼编码方法：
>
> 1. 统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）
> 2. 利用哈夫曼树的特点：权越大的叶子离根越近；将每个字符的概率值作为权值构造哈夫曼树。概率越大的结点路径越短。
> 3. 在哈夫曼树的每个分支上标上0或1:
>    - 结点的左分支标0，右分支标1
>    - 把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符编码

例子：传输的字符集 D = { C, A, S, T, ; }，字符出现的频率 W = { 2, 4, 2, 3, 3 }

<img src="/Users/georgetan/Documents/workspace/gitHub/js-algorithm-pattern/notes/images/哈夫曼编码分析.JPG" style="zoom:50%;" />

Q: 为什么哈夫曼编码能够保证是前缀编码？

因为哈夫曼树是最优二叉树，而二叉树中每个结点的分支路径只有俩条（左标为0，右标为1），这样的话就可以保证从根到达结点的路径必然是唯一的。

Q: 为什么哈夫曼编码能够保证字符编码总长最短？

因为哈夫曼树本身就是带权路径长度最短的树，故字符编码的总长最短。字符编码的长度即路径长度，权重即为出现的概率。
