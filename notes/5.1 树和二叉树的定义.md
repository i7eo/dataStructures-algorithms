## 定义

🌰：人类社会（行政机构组织划分）、编译（用树表示源程序的语法结构，ast语法树，html中dom树等，数据库系统用树组织信息（红黑树），算法分析（用树描述过程））

**树形结构（非线性结构）：结点之间有分支且具有层次关系**

树（Tree）是 n（n >= 0）个结点的有限集（可以用集合来表示，也可用树来表示，还可以用广义表来表示。最常用是树，既能描述出结点关系又能描述层次结构）；递归定义，自己引用并定义自己。

- 若 n = 0 称为空树
- 若 n > 0 则它满足如下俩个条件：
  - 有且仅有一个特定的称为根的结点
  - 其余结点可分为 m（m >= 0）个互不相交的有限集 T1, T2, T3, ..., Tm, 其中每一个集合本身又是一棵树，并称为根的子树（SubTree）

## 基本术语

<img src="/Users/georgetan/Documents/workspace/notes/数据结构与算法/images/树.JPG" style="zoom:20%;" />

- **连线表示结点间前驱和后继的关系**
- 元素被称为结点
- **根结点：非空树中无前驱结点的结点**
- **结点的度：结点拥有的子树个数，大于等于0**
- **树的度：树内各结点的度的最大值，3即根结点的度**
- **叶子结点：度为0的终端结点（无子结点）F G I J K L M**
- 分支结点：度不为0的非终端结点 A B C D E H；根结点以外的分支结点称为内部结点 B C D E H
- 子树：
  - T1 = B;  B = (E, F), E = (K, L)
  - T2 = C; C = (G)
  - T3 = D; D = (H, I, J), H = (M)
- **孩子结点：结点的子树的根称为该结点的孩子结点；该结点称为孩子的双亲**
- **兄弟结点：拥有共同双亲结点的结点**
- 堂兄弟结点：位于同一层的双亲结点的孩子结点例子： G H
- 结点的祖先：从根结点到该结点所经分支上的所有结点例子：M 的祖先包括 H D A
- 结点的子孙：以某结点为根的子树中的任一结点例子：D 的子孙包括 H I J M
- **树的深度（也称高度）：树中结点的最大层次** 4
- 有序树：树中结点的各个子树从左至右有次序（最左边的为第一个孩子）
- 无序树：树中结点的各个子树无次序
- **森林：是 m(m >= 0) 棵互不相交的树的集合** 不删除 A 结点也是森林不过森林中只有一棵树，删除 A 后森林里有三棵树 

## 树结构与线性结构的比较

|                  |  线性结构（1对1）  |       树结构（1对多）        |
| :--------------- | :----------------: | :--------------------------: |
| 第一个数据元素   |       无前驱       |       （根结点）无双亲       |
| 最后一个数据元素 |       无后继       | （叶子结点可以有多个）无孩子 |
| 其他数据元素     | 一个前驱，一个后继 |      一个双亲，多个孩子      |

## 二叉树

- 为什么要重点研究**每个结点最多只有俩个叉**的树？因为普通树（多叉树）若不转为二叉树，运算、存储都很复杂，很难实现。
- 二叉树的结构最简单，规律性最强
- 已经证明过**所有树都能转为唯一对应的二叉树**，不失一般性。
- 二叉树在树结构的应用中起着非常重要的作用，因为对二叉树的许多操作算法较简单明了，且任何树都可以与唯一的二叉树进行相互转换。这样就解决了树的存储结构及其运算中存在的复杂性

**二叉树**是 n(n >= 0 ) 个结点的有限集，它或者是空集 (n = 0)，或者由一个根结点及**俩棵互不相交**的分别称作这个根的左子树和右子树的二叉树组成

特点：

- 每个结点最多有俩个孩子（二叉树中不存在度大于2的结点）
- 子树有左右之分，其次序不能颠倒
- 二叉树可以是空集合，根可以有空的左子树或空的右子树

**注意**：

二叉树**不是树的特殊情况**，严格意义上来说是俩个概念。

**二叉树结点的子树必须要区分左子树和右子树，即使只有一棵子树也要进行区分，说明它是左子树还是右子树**。

树当结点只有一个孩子时，就**无须区分**它是左还是右的次序。因此俩者是不同的。这是二叉树与树的最主要差别。

也就是说二叉树每个结点位置或者说次序都是固定的，可以是空，但是不可以说他没有位置，而树结点位置是相对于别的结点来说的，没有别的结点时，他就无所谓左右。

### 思考

具有3个结点的二叉树可能有几种不同形态？普通树呢？

<img src="/Users/georgetan/Documents/workspace/notes/数据结构与算法/images/二叉树思考.JPG" style="zoom:20%;" />

### 五种形态

<img src="/Users/georgetan/Documents/workspace/notes/数据结构与算法/images/二叉树五种形态.JPG" style="zoom:20%;" />

## 树的应用案例

1. 数据压缩问题：将数据文件转换成由0、1组成的二进制串，称为编码。方法有：
   - 等长编码方案（a => 00, b => 01, c => 10, d => 11 00这种浪费了空间）
   - 不等长编码方案1（a => 0, b => 01, c => 110, d => 111 这种是最佳的）后面哈夫曼树会实现该方法
   - 不等长编码方案2（a => 0, b => 01, c => 010, d => 111 此时的a为0 也可代表b中的第一位编码）
2. 利用二叉树求解表达式的值（发散 ast抽象语法树、dom树）如下：

<img src="/Users/georgetan/Documents/workspace/notes/数据结构与算法/images/二叉树多项式.JPG" style="zoom:30%;" />

二叉树表示表达式的递归定义如下：

1. 若表达式为数或简单变量，则相应二叉树中仅有一个根结点，其数据域存放该表达式信息
2. 若表达式为**第一操作数 运算法 第二操作数**的形式，则相应的二叉树中以左子树表示第一操作数，右子树表示第二操作数，根结点的数据域存放运算符（若为一元运算符，则左子树为空），其中，操作数本身又为表达式

## 树和二叉树的抽象数据类型定义

```c
ADT BinaryTree {
  // 数据对象D: D是具有相同特性的数据元素的集合
  // 数据关系R: 若 D 为空，则 R 为空；若 D 不为空，则 R = {H}, H 是如下二元关系：
  // root唯一，子树不相交...
}ADT BinaryTree
```

### 基本操作

```c
CreatBiTree(&T, definition) {
	// 通过 definition 的二叉树定义构造二叉树并返回
}
```

```c
PreOrderTraverse(T) {
	// 二叉树T存在，先序遍历，对每个结点访问一次
}
```

```c
InOrderTraverse(T) {
	// 二叉树T存在，中序遍历，对每个结点访问一次
}
```

```c
PostOrderTraverse(T) {
	// 二叉树T存在，后序遍历，对每个结点访问一次
}
```



